<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"></meta>
        <title>Not So Simple</title>
        
        <link rel="icon", href="images/seed.png"></link>
        <link rel="stylesheet", href="view/nss.css"></link>
    </head>
    <body>
        <div id="main-div">
            <canvas id="canv", width=1280, height=720></canvas>
            <!-- <canvas id="canv", width=960, height=540></canvas> -->
            <!-- <canvas id="canv", width=640, height=360></canvas> -->
        </div>
        
        <script src="events.js"></script>
        <script src="Vector.js"></script>
        <script src="Rectangle.js"></script>
        <script src="Circle.js"></script>
        <script src="Polygon.js"></script>
        <script src="draft.js"></script>
        
        <script id="canvas", src="canvas.js"></script>
        
        <script src="images.js"></script>
        
        <script src="Drawable.js"></script>
        <script src="Entity.js"></script>
        <script src="Action.js"></script>
        <script src="interactions/Interaction.js"></script>
        <script src="Battler.js"></script>
        
        <script src="actions/draft-actions.js"></script>
        <script src="actions/cursorControl.js"></script>
        <script src="actions/Jump.js"></script>
        <script src="actions/Teleport.js"></script>
        <script src="actions/ProjectileShot.js"></script>
        <script src="actions/Movement.js"></script>
        <script src="actions/cutter.js"></script>
        <script src="actions/lcreate.js"></script>
        <script src="actions/sword.js"></script>
        <script src="actions/zyxei.js"></script>
        
        <script src="entities/draft-entities.js"></script>
        <script src="entities/Camera.js"></script>
        <script src="entities/PlayableCharacter.js"></script>
        <script src="entities/Adnyropast.js"></script>
        <script src="entities/Haple.js"></script>
        <script src="entities/Ten.js"></script>
        
        <script id="entitycollections">
        
        var entityClasses = {
            "entity" : Entity,
            "" : Entity
        };
        
        class EntityCollection extends Array {
            add(entity) {
                if(this.indexOf(entity) == -1) {
                    this.push(entity);
                }
                
                return this;
            }
            
            remove(entity) {
                var index = this.indexOf(entity);
                
                if(index != -1) {
                    this.splice(index, 1);
                }
                
                return this;
            }
            
            clear() {
                this.splice(0, this.length);
                
                return this;
            }
        }
        
        const NOENTITY = [];
        const ENTITIES = new EntityCollection();
        const COLLIDABLE = new EntityCollection();
        const DRAWABLE = new EntityCollection();
        const PLAYABLE = new EntityCollection();
        var CAMERA = TCamera.fromMiddle([BASEWIDTH / 2, BASEHEIGHT / 2], [640, 360]);
        var PLAYER = null;
        
        function addEntity(entity) {
            entity.onadd();
            
            ENTITIES.add(entity);
            
            if(entity.isCollidable()) {
                COLLIDABLE.add(entity);
            }
            
            if(entity instanceof PlayableCharacter) {
                PLAYABLE.add(entity);
                PLAYER = entity;
            }
            
            if(entity instanceof TCamera) {
                CAMERA = entity;
            }
        }
        
        function addEntities(entities) {
            for(var i = 0; i < entities.length; ++i) {
                addEntity(entities[i]);
            }
        }
        
        function removeEntity(entity) {
            entity.onremove();
            
            ENTITIES.remove(entity);
            COLLIDABLE.remove(entity);
            DRAWABLE.remove(entity);
            PLAYABLE.remove(entity);
            
            if(entity == PLAYER) {
                PLAYER = null;
            }
        }
        
        function clearEntities() {
            ENTITIES.clear();
            COLLIDABLE.clear();
            DRAWABLE.clear();
            PLAYABLE.clear();
        }
        
        function addDrawable(drawable) {
            DRAWABLE.add(drawable);
        }
        
        function removeDrawable(drawable) {
            DRAWABLE.remove(drawable);
        }
        
        </script>
        <script src="draft-controls.js"></script>
        <script>
        
        window.addEventListener("keydown", function(event) {
            if(PLAYER != null) {
                /**
                for(var i = 0; i < actionevents.length; ++i) {
                    if(actionevents[i].keys.includes(event.keyCode)) {
                        actionevents[i].oneventdown(PLAYER);
                    }
                }
                /**/
            }
        });
        
        window.addEventListener("keyup", function(event) {
            if(PLAYER != null) {
                for(var i = 0; i < actionevents.length; ++i) {
                    if(actionevents[i].keys.includes(event.keyCode)) {
                        actionevents[i].oneventup(PLAYER);
                    }
                }
            }
        });
        
        window.addEventListener("mousemove", function(event) {
            if(PLAYER != null) {
                PLAYER.addAction(new MouseFocus());
            }
        });
        
        window.addEventListener("contextmenu", function(event) {
            <!-- event.preventDefault(); -->
        });
        
        window.addEventListener("mousedown", function(event) {
            if(PLAYER != null) {
                PLAYER.addAction(new MouseFocus());
                /**
                for(var i = 0; i < actionevents.length; ++i) {
                    if(actionevents[i].mouse.includes(event.which)) {
                        actionevents[i].oneventdown(PLAYER);
                    }
                }
                /**/
            }
        });
        
        window.addEventListener("mouseup", function(event) {
            if(PLAYER != null) {
                PLAYER.removeActionsWithConstructor(MouseFocus);
                
                for(var i = 0; i < actionevents.length; ++i) {
                    if(actionevents[i].mouse.includes(event.which)) {
                        actionevents[i].oneventup(PLAYER);
                    }
                }
            }
        });
        
        function playerUpdate(player) {
            if(keyList.value(107)) {
                ++player.cursorDistance;
            } if(keyList.value(109)) {
                --player.cursorDistance;
            }
            
            for(var i = 0; i < actionevents.length; ++i) {
                if(keyList.value(actionevents[i].keys)) {
                    actionevents[i].oneventdown(player);
                } if(keyList.value(actionevents[i].presskeys) == 1) {
                    actionevents[i].oneventdown(player);
                } if(mouse.value(actionevents[i].mouse)) {
                    actionevents[i].oneventdown(PLAYER);
                }
            }
            
            /**
            if(keyList.value(67)) {
                player.addAction(new LCreation());
            } else {
                player.removeActionsWithConstructor(LCreation);
            }
            /**/
        }
        
        function worldLoop() {
            if(!PLAYER) {
                buildMaze();
                <!-- buildTest(); -->
            }
            
            let entities = EntityCollection.from(ENTITIES);
            let collidables = EntityCollection.from(COLLIDABLE);
            let drawables = EntityCollection.from(DRAWABLE);
            
            playerUpdate(PLAYER);
            
            for(var i = 0; i < entities.length; ++i) {
            <!-- for(var i = entities.length - 1; i >= 0; --i) { -->
                var entity = entities[i];
                
                entity.update();
                
                if(entity.isRemovable()) {
                    removeEntity(entity);
                }
            }
            
            for(var i = 0; i < entities.length; ++i) {
                var entity = entities[i];
                entity.updateReset();
            }
            
            keyList.increment();
            mouse.increment();
            
            collidables.sort(function(a, b) {
                if(a.collide_priority > b.collide_priority) {return -1;}
                if(a.collide_priority < b.collide_priority) {return +1;}
                return 0;
            });
            
            for(var i = 0; i < collidables.length; ++i) {
                for(var j = i + 1; j < collidables.length; ++j) {
                    if(collidables[i].collides(collidables[j])) {
                        collidables[i].oncollision(collidables[j]);
                        collidables[j].oncollision(collidables[i]);
                    }
                }
            }
            
            var context = CANVAS.getContext("2d");
            
            /** DRAWING UPDATE **
            
            context.fillStyle = "#FFFFFF3F";
            context.fillRect(0, 0, CANVAS.width, CANVAS.height);
            context.clearRect(0, 0, CANVAS.width, CANVAS.height);
            
            /**/
            
            drawables.sort(function(a, b) {
                if(a.getZIndex() > b.getZIndex()) {
                    return -1;
                } if(a.getZIndex() < b.getZIndex()) {
                    return +1;
                }
                
                return 0;
            });
            
            for(var i = 0; i < drawables.length; ++i) {
                /**
                if(i < drawables.length - 1 && drawables[i].getZIndex() < drawables[i + 1].getZIndex()) {
                    var drawable = drawables[i + 1];
                    drawables[i + 1] = drawables[i];
                    drawables[i] = drawable;
                }
                /**/
                var drawable = drawables[i];
                drawable.draw(context);
            }
        }
        
        const BATTLERS = new EntityCollection();
        const SKILLS = new EntityCollection();
        
        var battleturn = 0;
        var actorIndex = 0;
        
        function addBattler(battler) {
            if(battler instanceof Entity && battler.isBattler()) {
                BATTLERS.add(Battler.fromEntity(battler));
            }
        }
        
        function addBattlers(battlers) {
            for(var i = 0; i < battlers.length; ++i) {
                addBattler(battlers[i]);
            }
        }
        
        function addSkill(skill) {
            SKILLS.add(skill);
        }
        
        function removeSkill(skill) {
            SKILLS.remove(skill);
        }
        
        /**
        
        BATTLERS.sort(function(a, b) {
            if(a.getPriority() > b.getPriority) return -1;
            if(a.getPriority() < b.getPriority) return +1;
            return 0;
        });
        
        /**/
        
        function battlePreparingLoop() {
            for(var i = 0; i < BATTLERS.length; ++i) {
                var battler = BATTLERS[i];
                
                if(!battler.isReady()) {
                    return;
                }
            }
            
            switchLoop(battleActingLoop, WORLD_PACE);
        }
        
        function battleActingLoop() {
            SKILLS.sort(function() {
                return 0;
            });
            
            SKILLS[0].use();
        }
        
        function endofturn() {
            ++actorIndex;
            actorIndex %= BATTLERS.length;
        }
        
        var gameInterval;
        var gameLoop = worldLoop;
        
        function switchLoop(loopF, pace) {
            gameLoop = loopF;
            clearInterval(gameInterval);
            gameInterval = setInterval(loopF, pace);
        }
        
        function repaceLoop(pace) {
            clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, pace);
        }
        
        function loadCheck(nextLoop, nextPace) {
            if(loadCounter == 0) {
                for(var i = 0; i < IMGS.length; ++i) {
                    if(!IMGS[i].complete || IMGS[i].naturalWidth === 0) {
                        return;
                    }
                }
                
                switchLoop(nextLoop, nextPace);
            }
        }
        
        function engageBattle(battlers = NOENTITY) {
            addBattlers(battlers);
            switchLoop(battlePreparingLoop, WORLD_PACE);
        }
        
        switchLoop(loadCheck.bind(this, gameLoop, WORLD_PACE), 16);
        
        </script>
        <script src="draft-maps.js"></script>
    </body>
</html>